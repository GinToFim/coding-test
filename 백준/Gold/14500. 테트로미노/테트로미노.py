# 아이디어: 1. 모든 테트리미노 경우의 수 구하기
# 알고리즘: 구현, 시물레이션

n, m = map(int, input().split())

board = [list(map(int, input().split()))
        for _ in range(n)]

tetrominos = [
    [(0, 0), (0, 1), (0, 2), (0, 3)],
    [(0, 0), (1, 0), (2, 0), (3, 0)],

    [(0, 0), (0, 1), (1, 0), (1, 1)],

    [(0, 0), (1, 0), (2, 0), (2, 1)],
    [(0, 0), (1, 0), (2, 0), (2, -1)],
    [(0, 0), (0, 1), (1, 0), (2, 0)],
    [(0, 0), (0, 1), (1, 1), (2, 1)],
    [(0, 0), (1, 0), (1, 1), (1, 2)],
    [(0, 0), (0, 1), (0, 2), (-1, 2)],
    [(0, 0), (0, 1), (0, 2), (1, 0)],
    [(0, 0), (0, 1), (0, 2), (1, 2)],

    [(0, 0), (1, 0), (1, 1), (2, 1)],
    [(0, 0), (1, 0), (1, -1), (2, -1)],
    [(0, 0), (0, 1), (-1, 1), (-1, 2)],
    [(0, 0), (0, 1), (1, 1), (1, 2)],
    
    [(0, 0), (1, 0), (1, 1), (2, 0)],
    [(0, 0), (1, 0), (1, -1), (2, 0)],
    [(0, 0), (0, 1), (-1, 1), (0, 2)],
    [(0, 0), (0, 1), (1, 1), (0, 2)]
    
]

result = -1

for x in range(n):
    for y in range(m):
        for tertomino in tetrominos:
            now_score = 0
            flag = True
            for i, j in tertomino:
                nx = x + i
                ny = y + j

                # 범위 밖이라며 무시
                if nx < 0 or ny < 0 or nx >= n or ny >= m:
                    flag = False
                    break

                now_score += board[nx][ny]


            if flag:
                result = max(result, now_score)

print(result)